<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Funny PS1â€‘Vibe Racing Game</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; font-family: 'Press Start 2P', monospace; color: #fff; overflow: hidden; }
    #menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
    #menu h1 { margin-bottom: 20px; font-size: 24px; }
    #menu ul { list-style: none; padding: 0; }
    #menu li { margin: 10px 0; font-size: 18px; opacity: 0.5; transition: opacity 0.2s; }
    #menu li.selected { opacity: 1; }
    #vehicle-menu { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
    #vehicle-menu h1 { margin-bottom: 20px; font-size: 24px; }
    #vehicle-menu ul { list-style: none; padding: 0; }
    #vehicle-menu li { margin: 10px 0; font-size: 18px; opacity: 0.5; transition: opacity 0.2s; }
    #vehicle-menu li.selected { opacity: 1; }
    #gameCanvas { display: none; width: 100%; height: 100%; }
    #crt-overlay { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; background-image: repeating-linear-gradient(to bottom, rgba(0,0,0,0) 0px, rgba(0,0,0,0.1) 1px, rgba(0,0,0,0) 2px); mix-blend-mode: multiply; }
  </style>
</head>
<body>
  <div id="menu">
    <h1>PS1 Vibe Racer</h1>
    <ul id="menu-options">
      <li data-index="0" class="selected">Start Race</li>
      <li data-index="1">Select Vehicle</li>
      <li data-index="2">Toggle Music/SFX</li>
      <li data-index="3">View High Scores</li>
      <li data-index="4">Toggle CRT: On</li>
    </ul>
  </div>
  <div id="vehicle-menu">
    <h1>Select Vehicle</h1>
    <ul id="vehicle-options">
      <li data-index="0" class="selected">Toaster Car</li>
      <li data-index="1">Rubber Duck</li>
      <li data-index="2">Squeaky Hamburger</li>
    </ul>
  </div>
  <canvas id="gameCanvas"></canvas>
  <div id="crt-overlay"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r146/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.41/Tone.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>
  <script>
    const menu = document.getElementById('menu');
    const options = [...document.querySelectorAll('#menu-options li')];
    let menuIndex = 0;
    let selectedVehicle = 'Toaster Car';
    let isMusicMuted = false;
    let inVehicleMenu = false;
    let vehicleMenuIndex = 0;
    const vehicleMenu = document.getElementById('vehicle-menu');
    const vehicleOptions = [...document.querySelectorAll('#vehicle-options li')];
    let isCRTEnabled = true;
    const crtOverlay = document.getElementById('crt-overlay');
    let composer, crtPass;
    const CRTShader = {
      uniforms: {
        tDiffuse: { value: null },
        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
      },
      vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
      fragmentShader: `uniform sampler2D tDiffuse; uniform vec2 resolution; varying vec2 vUv; void main(){ vec2 uv=vUv; vec2 c=uv*2.0-1.0; c.x*=1.0+(abs(c.y)/resolution.x)*0.1; c.y*=1.0+(abs(c.x)/resolution.y)*0.1; uv=(c+1.0)/2.0; vec4 col=texture2D(tDiffuse,uv); float scan=sin(uv.y*resolution.y*1.5)*0.03; col.rgb-=scan; gl_FragColor=col; }`
    };

    // MENU FUNCTIONS
    function updateMenu() {
      options.forEach(opt => opt.classList.remove('selected'));
      options[menuIndex].classList.add('selected');
    }
    window.addEventListener('keydown', e => {
      if (inVehicleMenu) {
        if (e.code === 'ArrowUp') { vehicleMenuIndex = (vehicleMenuIndex - 1 + vehicleOptions.length) % vehicleOptions.length; updateVehicleMenu(); }
        if (e.code === 'ArrowDown') { vehicleMenuIndex = (vehicleMenuIndex + 1) % vehicleOptions.length; updateVehicleMenu(); }
        if (e.code === 'Enter') { confirmVehicle(); }
        if (e.code === 'Escape') { vehicleMenu.style.display = 'none'; menu.style.display = 'block'; inVehicleMenu = false; return; }
      }
      if (menu.style.display !== 'none') {
        if (e.code === 'ArrowUp') { menuIndex = (menuIndex - 1 + options.length) % options.length; updateMenu(); }
        if (e.code === 'ArrowDown') { menuIndex = (menuIndex + 1) % options.length; updateMenu(); }
        if (e.code === 'Enter') { selectOption(menuIndex); }
      }
    });
    function selectOption(index) {
      switch (index) {
        case 0: startRace(); break;
        case 1: selectVehicle(); break;
        case 2: toggleAudio(); break;
        case 3: viewHighScores(); break;
        case 4: toggleCRT(); break;
      }
    }
    function startRace() {
      menu.style.display = 'none';
      document.getElementById('gameCanvas').style.display = 'block';
      setupAudio();
      initGame();
    }
    function selectVehicle() {
      menu.style.display = 'none';
      vehicleMenu.style.display = 'block';
      inVehicleMenu = true;
      vehicleMenuIndex = 0;
      updateVehicleMenu();
    }
    function toggleAudio() {
      isMusicMuted = !isMusicMuted;
      if (isMusicMuted) Tone.Transport.pause(); else Tone.Transport.start();
      options[2].textContent = isMusicMuted ? 'Unmute Audio' : 'Mute Audio';
    }
    function viewHighScores() {
      const scores = JSON.parse(localStorage.getItem('highScores') || '[]');
      let msg = 'High Scores:\n';
      if (scores.length === 0) msg += 'No records yet.';
      else scores.forEach((s,i) => msg += `${i+1}. ${s.name}: ${s.time}s\n`);
      alert(msg);
    }

    // VEHICLE MENU HELPERS
    function updateVehicleMenu() {
      vehicleOptions.forEach(opt => opt.classList.remove('selected'));
      vehicleOptions[vehicleMenuIndex].classList.add('selected');
    }
    function confirmVehicle() {
      selectedVehicle = vehicleOptions[vehicleMenuIndex].textContent;
      options[1].textContent = 'Select Vehicle: ' + selectedVehicle;
      vehicleMenu.style.display = 'none';
      menu.style.display = 'block';
      inVehicleMenu = false;
    }

    // GAME & THREE.JS SETUP
    let scene, camera, renderer, vehicle, keys = {}, trackCurve;
    let physicsWorld, chassisBody, vehiclePhysics;

    function initGame() {
      const canvas = document.getElementById('gameCanvas');
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      // POSTPROCESSING CRT EFFECT
      composer = new THREE.EffectComposer(renderer);
      composer.addPass(new THREE.RenderPass(scene, camera));
      crtPass = new THREE.ShaderPass(CRTShader);
      composer.addPass(crtPass);
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.position.set(0, 5, 10);
      window.addEventListener('resize', onWindowResize);
      setupPhysics();
      setupScene();
      animate();
    }
    function setupPhysics() {
      physicsWorld = new CANNON.World();
      physicsWorld.gravity.set(0, -9.82, 0);
      physicsWorld.broadphase = new CANNON.NaiveBroadphase();
      physicsWorld.solver.iterations = 10;
      // Ground plane
      const groundBody = new CANNON.Body({ mass: 0 });
      groundBody.addShape(new CANNON.Plane());
      groundBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
      physicsWorld.addBody(groundBody);
      // Chassis
      chassisBody = new CANNON.Body({ mass: 150 });
      chassisBody.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.25, 1)));
      chassisBody.position.set(0, 1, 0);
      // Raycast vehicle
      vehiclePhysics = new CANNON.RaycastVehicle({
        chassisBody: chassisBody,
        indexRightAxis: 0,
        indexUpAxis: 1,
        indexForwardAxis: 2
      });
      const wheelOptions = {
        radius: 0.4,
        directionLocal: new CANNON.Vec3(0, -1, 0),
        axleLocal: new CANNON.Vec3(-1, 0, 0),
        suspensionStiffness: 30,
        suspensionRestLength: 0.3,
        frictionSlip: 5,
        dampingRelaxation: 2.3,
        dampingCompression: 4.4,
        maxSuspensionForce: 100000,
        rollInfluence: 0.01,
        maxSuspensionTravel: 0.3,
        customSlidingRotationalSpeed: -30,
        useCustomSlidingRotationalSpeed: true
      };
      const wheelPositions = [
        new CANNON.Vec3(-0.7, 0, 1.2),
        new CANNON.Vec3(0.7, 0, 1.2),
        new CANNON.Vec3(-0.7, 0, -1.2),
        new CANNON.Vec3(0.7, 0, -1.2)
      ];
      wheelPositions.forEach(pos => {
        const opt = { ...wheelOptions, chassisConnectionPointLocal: pos };
        vehiclePhysics.addWheel(opt);
      });
      vehiclePhysics.addToWorld(physicsWorld);
      physicsWorld.addBody(chassisBody);
    }
    function setupScene() {
      // Ground
      const groundGeom = new THREE.PlaneGeometry(100, 100);
      const trackTex = generateTrackTexture();
      trackTex.repeat.set(20, 20);
      const groundMat = new THREE.MeshBasicMaterial({ map: trackTex });
      const ground = new THREE.Mesh(groundGeom, groundMat);
      ground.rotation.x = -Math.PI/2;
      scene.add(ground);
      // Create spline-based track
      trackCurve = createTrack();

      // Vehicle
      const baseColor = selectedVehicle === 'Rubber Duck' ? '#FFD23F' : selectedVehicle === 'Squeaky Hamburger' ? '#8B4513' : '#FF8C00';
      vehicle = createVehicle(baseColor);
      vehicle.position.y = 0.25;
      scene.add(vehicle);
      // Input
      window.addEventListener('keydown', e => keys[e.code] = true);
      window.addEventListener('keyup', e => keys[e.code] = false);
    }
    function createVehicle(color) {
      const geom = new THREE.BoxGeometry(1, 0.5, 2);
      const tex = generateProceduralTexture(color);
      const mat = new THREE.MeshBasicMaterial({ map: tex });
      return new THREE.Mesh(geom, mat);
    }

    // SPLINE-BASED TRACK GENERATION
    function createTrack() {
      // Choose a random layout
      const layouts = [
        [new THREE.Vector3(-20,0,-20), new THREE.Vector3(20,0,-20), new THREE.Vector3(20,0,20), new THREE.Vector3(-20,0,20)],
        [new THREE.Vector3(-15,0,0), new THREE.Vector3(0,0,15), new THREE.Vector3(15,0,0), new THREE.Vector3(0,0,-15)],
        [new THREE.Vector3(-20,0,-10), new THREE.Vector3(-10,0,20), new THREE.Vector3(10,0,-20), new THREE.Vector3(20,0,10)]
      ];
      const pts = layouts[Math.floor(Math.random()*layouts.length)];
      const curve = new THREE.CatmullRomCurve3(pts, true);
      // Cross-section shape (track width and thickness)
      const shape = new THREE.Shape();
      const w = 5, h = 0.2;
      shape.moveTo(-w/2, -h/2);
      shape.lineTo(w/2, -h/2);
      shape.lineTo(w/2, h/2);
      shape.lineTo(-w/2, h/2);
      shape.closePath();
      const extrudeSettings = { steps: 200, bevelEnabled: false, extrudePath: curve };
      const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      geo.rotateX(-Math.PI/2);
      const tex = generateTrackTexture();
      tex.repeat.set(200,1);
      const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
      const mesh = new THREE.Mesh(geo, mat);
      scene.add(mesh);
      // Add decorative bumps along the track
      createTrackBumps(curve, w);
      return curve;
    }

    // Decorative track bumps (not obstacles)
    function createTrackBumps(curve, width) {
      const count = 30;
      for (let i = 0; i < count; i++) {
        const t = Math.random();
        const pos = curve.getPointAt(t);
        const tan = curve.getTangentAt(t);
        const angle = Math.atan2(tan.x, tan.z);
        const bumpGeom = new THREE.BoxGeometry(width*1.2, 0.1, 0.2);
        const bumpMat = new THREE.MeshBasicMaterial({ color: 0x888888 });
        const bump = new THREE.Mesh(bumpGeom, bumpMat);
        bump.position.set(pos.x, 0.05, pos.z);
        bump.rotation.y = angle;
        scene.add(bump);
        // Physics body for bump
        if (physicsWorld) {
          const halfExt = new CANNON.Vec3(width*1.2/2, 0.1/2, 0.2/2);
          const bumpBody = new CANNON.Body({ mass: 0 });
          bumpBody.addShape(new CANNON.Box(halfExt));
          bumpBody.position.set(pos.x, 0.05, pos.z);
          bumpBody.quaternion.setFromEuler(0, angle, 0);
          physicsWorld.addBody(bumpBody);
        }
      }
    }

    // ANIMATION LOOP
    function animate() {
      requestAnimationFrame(animate);
      // Physics step
      if (physicsWorld) {
        // Control input
        const maxForce = 1500;
        const maxSteer = 0.5;
        // Engine force
        if (keys.ArrowUp) {
          vehiclePhysics.applyEngineForce(-maxForce, 2);
          vehiclePhysics.applyEngineForce(-maxForce, 3);
        } else if (keys.ArrowDown) {
          vehiclePhysics.applyEngineForce(maxForce, 2);
          vehiclePhysics.applyEngineForce(maxForce, 3);
        } else {
          vehiclePhysics.applyEngineForce(0, 2);
          vehiclePhysics.applyEngineForce(0, 3);
        }
        // Steering
        if (keys.ArrowLeft) {
          vehiclePhysics.setSteeringValue(maxSteer, 0);
          vehiclePhysics.setSteeringValue(maxSteer, 1);
        } else if (keys.ArrowRight) {
          vehiclePhysics.setSteeringValue(-maxSteer, 0);
          vehiclePhysics.setSteeringValue(-maxSteer, 1);
        } else {
          vehiclePhysics.setSteeringValue(0, 0);
          vehiclePhysics.setSteeringValue(0, 1);
        }
        // Step world
        physicsWorld.step(1/60);
        // Sync mesh with physics
        vehicle.position.copy(chassisBody.position);
        vehicle.quaternion.copy(chassisBody.quaternion);
      }
      camera.position.set(vehicle.position.x, vehicle.position.y + 5, vehicle.position.z + 10);
      camera.lookAt(vehicle.position);
      if(isCRTEnabled && composer) composer.render(); else renderer.render(scene, camera);
    }

    // PROCEDURAL TEXTURE
    function generateProceduralTexture(color) {
      const size = 32;
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = color; ctx.fillRect(0, 0, size, size);
      for (let i = 0; i < 100; i++) {
        ctx.fillStyle = `hsl(${Math.random()*360}, 80%, 60%)`;
        ctx.fillRect(Math.random()*size, Math.random()*size, 1, 1);
      }
      const texture = new THREE.CanvasTexture(canvas);
      texture.magFilter = THREE.NearestFilter;
      texture.minFilter = THREE.NearestFilter;
      return texture;
    }

    // TRACK PROCEDURAL TEXTURE GENERATOR
    function generateTrackTexture() {
      const size = 32;
      const canvas = document.createElement('canvas'); canvas.width = canvas.height = size;
      const ctx = canvas.getContext('2d');
      // Base color
      ctx.fillStyle = '#555'; ctx.fillRect(0, 0, size, size);
      // Light noise
      for (let i = 0; i < 400; i++) {
        const x = Math.random() * size, y = Math.random() * size;
        ctx.fillStyle = `rgba(200,200,200,${Math.random() * 0.2})`;
        ctx.fillRect(x, y, 1, 1);
      }
      // Ketchup splats
      for (let i = 0; i < 15; i++) {
        const x = Math.random() * size, y = Math.random() * size, r = Math.random() * 3 + 1;
        ctx.fillStyle = 'rgba(200,0,0,0.7)'; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
      }
      // Paw prints
      for (let i = 0; i < 10; i++) {
        const x = Math.random() * (size - 6) + 3, y = Math.random() * (size - 6) + 3;
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        for (let p = 0; p < 5; p++) {
          const angle = Math.random() * Math.PI * 2;
          const rx = x + Math.cos(angle) * 2, ry = y + Math.sin(angle) * 2;
          ctx.beginPath(); ctx.arc(rx, ry, 1, 0, Math.PI * 2); ctx.fill();
        }
      }
      const texture = new THREE.CanvasTexture(canvas);
      texture.magFilter = THREE.NearestFilter;
      texture.minFilter = THREE.NearestFilter;
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      return texture;
    }

    // AUDIO
    function setupAudio() {
      Tone.Transport.bpm.value = 130;
      const lead = new Tone.Synth({ oscillator: { type: 'square' } }).toDestination();
      const bass = new Tone.Synth({ oscillator: { type: 'triangle' } }).toDestination();
      new Tone.Sequence((t,n) => lead.triggerAttackRelease(n, '8n', t), ['C4','E4','G4','B4'], '4n').start(0);
      new Tone.Sequence((t,n) => bass.triggerAttackRelease(n, '2n', t), ['C2','C2','C2','C2'], '1n').start(0);
      Tone.Transport.start();
    }

    // RESIZE HANDLER
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      if(composer) {
        composer.setSize(window.innerWidth, window.innerHeight);
        CRTShader.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
      }
    }

    // CRT TOGGLE
    function toggleCRT() {
      isCRTEnabled = !isCRTEnabled;
      crtOverlay.style.display = isCRTEnabled ? 'block' : 'none';
      options[4].textContent = isCRTEnabled ? 'Toggle CRT: On' : 'Toggle CRT: Off';
    }
  </script>
</body>
</html>
